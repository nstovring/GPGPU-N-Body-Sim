//--------------------------------------------------------------------------------------
// File: ComputeShaderSort11.hlsl
//
// This file contains the compute shaders to perform GPU sorting using DirectX 11.
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------

#pragma kernel RadixSort
//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------

#define BITONIC_BLOCK_SIZE 512
#define TRANSPOSE_BLOCK_SIZE 16

#define THREADX 32
#define THREADY 1
#define GROUP_THREADS THREADX * THREADY
//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB
{
    uint g_iLevel;
    uint g_iLevelMask;
    uint g_iWidth;
    uint g_iHeight;
};

struct particle{
float3 pos;
float3 dir;
float3 color;
float radius;
uint morton;
int collision;
};
//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
StructuredBuffer<particle> Input : register( t0 );
RWStructuredBuffer<particle> Data : register( u0 );

bool getBit(uint i, uint n) {
	return ((n >> i) & 1) == 1;
}

groupshared particle o[GROUP_THREADS];
groupshared uint e[GROUP_THREADS];
groupshared uint f[GROUP_THREADS];

groupshared uint d[GROUP_THREADS];
groupshared uint totalFalses;

[numthreads(THREADX, 1, 1)]
void RadixSort(uint3 Gid  : SV_GroupID,
	uint3 DTid : SV_DispatchThreadID,
	uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex){

	o[GI] = Data[DTid.x];
	// loop through each bit
	[unroll(32)]
	for (int n = 0; n < 32; n++) {

		// e is 1 where the nth bit is 0.
		e[GI] = getBit(n, o[GI].morton) == 0;

		GroupMemoryBarrierWithGroupSync(); // wait for e to be populated so we can random access it

		if (GI != 0) {
			f[GI] = e[GI - 1];
		}
		else {
			f[GI] = 0;
		}

		GroupMemoryBarrierWithGroupSync(); // wait for f to be populated before we loop on it
	
		// Scan Operation (AKA Prefix Sum)
		[unroll(int(log2(GROUP_THREADS)))]
		for (uint i = 1; i < GROUP_THREADS; i <<= 1) { //for n = 0 .. log2(N), i =  2^n
			uint temp;
			if (GI > i) {
				temp = f[GI] + f[GI-i];
			}
			else {
				temp = f[GI];
			}
			GroupMemoryBarrierWithGroupSync();
			f[GI] = temp;
			GroupMemoryBarrierWithGroupSync();

		}
		//o[GI].morton = f[GI];
		//Data[idx] = o[GI];
		//return;
		// Sum up the falses
		if (GI == 0) {
			totalFalses = e[GROUP_THREADS - 1] + f[GROUP_THREADS - 1];
		}

		GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to finish

		// t contains the indexes for the 1 bits
		//t[GI] = GI - f[GI] + totalFalses;

		// we now construct t on the fly

		// d contains the destination indexes for all the bits
		d[GI] = e[GI] ? f[GI] : GI - f[GI] + totalFalses;

		// get the variable
		particle temp = o[GI];
		//particle temp = Input[DTid.x];
		//particle temp = 
		GroupMemoryBarrierWithGroupSync(); // read-before-write

		// rewrite o
		o[d[GI]] = temp;
		//Input[d[GI]] = 
		GroupMemoryBarrierWithGroupSync(); // wait for o to be fully populated

	}
	//	uint count,stride;
	//Input.GetDimensions(count,stride);
	Data[DTid.x]= o[d[GI]];
	
	//Data[DTid.x].collision = index;//o[d[GI]]; //DTid.x% GROUP_THREADS) +(DTid.x% GROUP_THREADS) + groupnumber
	//GroupMemoryBarrierWithGroupSync();

	}

