// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSSprings
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct particle{
	float3 position;
	float3 velocity;
	float mass;
	int isFixed;
	int iD;
	int springs[16];
};

struct spring {
	float damping;
	float stiffness;
	float restLength;
	int connectionA;
	int connectionB;
	int springType;
};

struct clothVertex {
	float3 vertex;
	int index;
};

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<spring> springs;
RWStructuredBuffer<clothVertex> vertexBuffer;
StructuredBuffer<float3> initialPositions;

float deltaTime;
float stiffness;
float damping;
float mass;
float gravityMul;

float3 fixedPos;
float3 spherePos;

float3 Normalize(float3 v) {
	float len = length(v);
	float3 normal = (len == 0.0) ? float3(0.0, 0.0, 0.0) : v / len;
	return normal;
}
bool IsValidSpring(int x)
{
	if (x != -1)
		return true;
	return false;
}

float3 calculateAirResistanceForce(float3 velocity, float dragCoeffecient, float crossAreal)
{
    float airDensity = 1.225f;
    float3 dragForce = (0.5f) * airDensity * (pow(velocity, 2)) * dragCoeffecient * crossAreal;
    return dragForce;
}

[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	particle p = particles[id.x];
	if (!(p.isFixed == 1)) {
		float3 gravity = float3(0, -9.8, 0) * gravityMul;
		
		//Euler integration
		//---------------------------------------------
		int steps = 1;
		float delta = deltaTime / steps;
		float3 velocity = p.velocity;
		float3 position = p.position;

		float3 dampingForce = float3(0, 0, 0);
		float3 springForce = float3(0, 0, 0);

		for (int i = 0; i < 16; i++)
		{
			if (IsValidSpring(p.springs[i])) {
				spring s = springs[p.springs[i]];
                particle b = particles[s.connectionB];
                particle a = particles[s.connectionA];
                bool reversed = b.iD != p.iD;
                if (reversed)
                {
                    b = a;
                    a = p;
                }

                dampingForce += -s.damping * (b.velocity - a.velocity);
                springForce += -s.stiffness * (a.position - b.position) * (s.restLength - distance(b.position, a.position));
			}
		}
		//Super Simple Collision
		float3 c = distance(position + velocity * delta, spherePos) < 6.54 ? Normalize(position + velocity * delta - spherePos) * (10 - distance(position + velocity * delta, spherePos)) : float3(0, 0, 0);
        //Plane Collision
        float3 cP = (position + velocity * delta).y < 0.1 ? float3(0, 1, 0) * (1 - (position + velocity * delta).y) : float3(0, 0, 0);


        float3 force = dampingForce + springForce + 1 * gravity;// + airResistanceForce;
	
		float3 acceleration = force / 1;
	
		//acceleration *= delta;
        velocity = velocity + acceleration * delta + c + cP;

		//velocity *= delta;
		position = position + velocity * delta;
		//--------------------------------------------

		
		particles[id.x].position = position;
		particles[id.x].velocity = velocity;

	}
	else {
		//float3 endPos = (fixedPos - p.position);
		
		particles[id.x].position = initialPositions[id.x] + fixedPos;// p.position + (fixedPos - initialPositions[id.x]);// *deltaTime;// +(fixedPos - p.position) * distance(fixedPos, p.position) * p.iD;
		particles[id.x].velocity = p.velocity;
	}
	DeviceMemoryBarrierWithGroupSync();
}


[numthreads(8, 1, 1)]
void CSSprings(uint3 id : SV_DispatchThreadID) {

	spring s = springs[id.x];

	particle a = particles[s.connectionA];
	particle b = particles[s.connectionB];

	float dist =pow( distance(b.position, a.position),4);
	float3 N = normalize(b.position - a.position);

	//a.velocity +=;
	//b.velocity += ;
	particles[s.connectionA].velocity += N * dist * deltaTime* 0.001;
	particles[s.connectionB].velocity += -N * dist * deltaTime * 0.001;

}
