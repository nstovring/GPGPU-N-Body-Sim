// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSSprings
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct particle{
	float3 position;
	float3 velocity;
	float mass;
	int isFixed;
	int iD;
	int springs[16];
};

struct spring {
	float damping;
	float stiffness;
	float restLength;
	int connectionA;
	int connectionB;
	int springType;
};

struct clothVertex {
	float3 vertex;
	int index;
};

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<spring> springs;
RWStructuredBuffer<clothVertex> vertexBuffer;
StructuredBuffer<float3> initialPositions;

float deltaTime;
float stiffness;
float damping;
float mass;
float gravityMul;

float3 fixedPos;
float3 spherePos;

float3 Normalize(float3 v) {
	float len = length(v);
	float3 normal = (len == 0.0) ? float3(0.0, 0.0, 0.0) : v / len;
	return normal;
}
bool IsValidSpring(int x)
{
	if (x != -1)
		return true;
	return false;
}
[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	particle p = particles[id.x];
	if (!(p.isFixed == 1)) {
		float3 gravity = float3(0, -9.8, 0) * gravityMul;
		
		//Euler integration
		//---------------------------------------------
		int steps = 1;
		float delta = deltaTime / steps;
		float3 velocity = p.velocity;
		float3 position = p.position;

		float3 dampingForce = float3(0, 0, 0);
		float3 springForce = float3(0, 0, 0);

		for (int i = 0; i < p.springs.Length; i++)
		{
			if (IsValidSpring(p.springs[i])) {
				spring s = springs[p.springs[i]];

				bool N = particles[s.connectionB].iD == p.iD;
				if (particles[s.connectionB].iD == p.iD) {
					dampingForce += s.damping * (particles[s.connectionA].velocity - velocity);// (-1 * Normalize(velocity)) * length(velocity);
					springForce += (-s.stiffness *(position - particles[s.connectionA].position) * stiffness) * (distance(position, particles[s.connectionA].position) - s.restLength);
				}																				
				else {																			
					dampingForce += s.damping * (particles[s.connectionB].velocity - velocity);
					springForce += (-s.stiffness *(position - particles[s.connectionB].position)  * stiffness) * ( distance(position, particles[s.connectionB].position) - s.restLength);
				}
			}
		}

		//Super Simple Collision
		float3 c = distance(position + velocity * delta, spherePos) < 0.54 ? Normalize(position + velocity * delta - spherePos) * (1 - distance(position + velocity * delta, spherePos)) : float3(0, 0, 0);

		float3 force = dampingForce + springForce + p.mass * gravity;
	
		float3 acceleration = force / p.mass;
	
		acceleration *= delta;
		velocity = velocity + acceleration * delta + c ;

	
		//velocity *= delta;
		position = position + velocity * delta;
		//--------------------------------------------

		
		particles[id.x].position = position;
		particles[id.x].velocity = velocity;

	}
	else {
		//float3 endPos = (fixedPos - p.position);
		
		particles[id.x].position = initialPositions[id.x] + fixedPos;// p.position + (fixedPos - initialPositions[id.x]);// *deltaTime;// +(fixedPos - p.position) * distance(fixedPos, p.position) * p.iD;
		particles[id.x].velocity = p.velocity;
	}
	DeviceMemoryBarrierWithGroupSync();
}


[numthreads(8, 1, 1)]
void CSSprings(uint3 id : SV_DispatchThreadID) {

	spring s = springs[id.x];

	particle a = particles[s.connectionA];
	particle b = particles[s.connectionB];

	float dist =pow( distance(b.position, a.position),4);
	float3 N = normalize(b.position - a.position);

	//a.velocity +=;
	//b.velocity += ;
	particles[s.connectionA].velocity += N * dist * deltaTime* 0.001;
	particles[s.connectionB].velocity += -N * dist * deltaTime * 0.001;

}
