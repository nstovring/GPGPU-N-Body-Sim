// shadertype=unity
// Each #kernel tells which function to compile; you can have many kernels


//#pragma kernel CSLoad

#include "BVHTraversal.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


float DeltaTime;
float speed;
float angularSpeed;
float gravity;
float radius;
float3 gravityVec;
float3 sphereColliderPos;


float3 ApplyVelocity(float3 direction){
	float c = 0.1;
	float3 friction = normalize(direction) *-1 * c;
	direction += friction * DeltaTime;
	direction += gravityVec * gravity  * DeltaTime;
	return direction;
}
float3 Normalize(float3 v) {
	float len = length(v);
	float3 normal = (len == 0.0) ? float3(0.0, 0.0, 0.0) : v / len;
	return normal;
}

float3 calculateCollisionForce(float3 i, float3 j, float k, float diameter, float3 vi, float3 vj, float damping) {
	float3 repulsiveForce = float3(0, 0, 0);
    float3 tangentialForce = float3(0, 0, 0);
    float3 dampingForce = float3(0, 0, 0);
	float3 rPosition = j - i;
	float3 rVelocity = vj - vi;

    repulsiveForce = -k * (diameter - distance(i,j)) * (Normalize(rPosition));

	dampingForce = (rVelocity) * damping;
    tangentialForce =(rVelocity - (dot(rVelocity, Normalize(rPosition))) * Normalize(rPosition));
    return repulsiveForce + dampingForce + tangentialForce;
}

#pragma kernel TraversalKernel
[numthreads(MainKernelThreadX, 1, 1)]
void TraversalKernel(uint3 id : SV_DispatchThreadID, uint3 Gid : SV_GroupID,
	uint3 GTid : SV_GroupThreadID,
	uint GI : SV_GroupIndex)
{
    internalNode leaf = boundingLeafNodes[id.x]; //inputPoints[leafNodes[id.x].objectId];
    particle curParticle = mergeOutputBuffer[leaf.objectId]; //;mergeOutputBuffer[leaf.objectId];
    float3 velocity = curParticle.direction;
    float3 curPoint = curParticle.position;
    float3 collisionForce = float3(0, 0, 0);
    float3 steeringForce = float3(0, 0, 0);
    int collisionList[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };

    TraverseBVHIterative(leaf, radius, collisionList);
	//[unroll(32)]
    for (int i = 0; i < 32; i++)
    {
        if (collisionList[i] > -1 && collisionList[i] != leaf.objectId)
        {
            particle p = mergeOutputBuffer[collisionList[i]];
    
            float dist = distance(curPoint, p.position);
            if (dist < radius * 2)//  t > 0 && t < 1)// d <= pow(radius*2,2))
            {
                float3 c = calculateCollisionForce(curPoint, p.position, 1 * angularSpeed, radius * 2, velocity, p.direction, 0.1);
                collisionForce += c;
            }
            //steeringForce += p.direction * (radius * 2 - distance(curPoint, p.position));
        }
    }

    float dist = distance(curPoint * 20,sphereColliderPos);
    if (dist < (radius *20*2 + 5))//  t > 0 && t < 1)// d <= pow(radius*2,2))
    {
        float3 c = -Normalize(sphereColliderPos - curPoint) * gravity;
        collisionForce += c;
    }
    //if (curPoint.y < 0 + radius)
    //{
    //    collisionForce += calculateCollisionForce(curPoint, float3(curPoint.x, 0 + radius, curPoint.z), gravityVec.y, radius * 2, velocity, float3(0, 1, 0), 0.1);
    //}
    float mass = 0.025;

    float3 force = collisionForce + gravityVec * gravity * mass + steeringForce;
    float3 acceleration = force / mass;
	//acceleration *= DeltaTime;
    velocity = velocity + acceleration * DeltaTime; // +collisionForce;

    velocityBuffer[leaf.objectId] = velocity;

}


#pragma kernel CSMain
[numthreads(MainKernelThreadX, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 Gid  : SV_GroupID,
	uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
    internalNode leaf = boundingLeafNodes[id.x]; //inputPoints[leafNodes[id.x].objectId];
    particle curParticle = mergeOutputBuffer[leaf.objectId]; //;mergeOutputBuffer[leaf.objectId];
    float3 velocity = velocityBuffer[leaf.objectId];
	float3 curPoint = curParticle.position;

    float scale = 1;

    if (curPoint.x > scale - radius)
    {
        curPoint.x = scale - radius;
        velocity.x *= -scale;
    }
    else if (curPoint.x < 0 + radius)
    {
        curPoint.x = 0 + radius;
        velocity.x *= -1;
    }
	
    if (curPoint.y > scale - radius)
    {
        curPoint.y = scale - radius;
        velocity.y *= -1;
    }
	else if(curPoint.y < 0 + radius){
	curPoint.y = 0 + radius;
	velocity.y *=-0.9;
	}
	
    if (curPoint.z > scale - radius)
    {
        curPoint.z = scale - radius;
        velocity.z *= -1;
    }
    else if (curPoint.z < 0 + radius)
    {
        curPoint.z = 0 + radius;
        velocity.z *= -1;
    }

	curPoint = curPoint + velocity * DeltaTime * speed;

	
    curParticle.direction = velocity;
    curParticle.position = curPoint;
    curParticle.mortonId = morton3D(curPoint.x, curPoint.y, curPoint.z);
    curParticle.radius = radius;
    inputPoints[id.x] = curParticle;
	//DeviceMemoryBarrier();
}


#pragma kernel WriteNodeData
[numthreads(ThreadX, 1, 1)]
void WriteNodeData(uint3 id : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
    inputPoints[id.x] = mergeOutputBuffer[id.x];
    internalNode leaf = leafNodes[id.x];
	leaf.parentId = -1;
	leaf.objectId = id.x;
	leaf.nodeId = id.x;
	leaf.mortonId = mergeOutputBuffer[id.x].mortonId;
	leaf.minPos = mergeOutputBuffer[id.x].position - float3(radius, radius, radius);
	leaf.maxPos = mergeOutputBuffer[id.x].position + float3(radius, radius, radius);
    leaf.sRadius = radius;
	
    leafNodes[id.x] = leaf;
    boundingLeafNodes[id.x] = leaf;

    uint count, stride;
    boundingInternalNodes.GetDimensions(count, stride);
    if (id.x >= count)
        return;

    internalNode intNode = internalNodes[id.x];
    intNode.parentId = -1;
    intNode.objectId = -1;
    intNode.visited = 0;
    intNode.nodeId = id.x;
    internalNodes[id.x] = intNode;
    boundingInternalNodes[id.x] = intNode;

}





#pragma kernel CSSortMortonIDs
[numthreads(ThreadX,1,1)]
void CSSortMortonIDs (uint3 id : SV_DispatchThreadID)
{
	float3 particlePos =  inputPoints[id.x].position; 
	uint mortonid = morton3D(particlePos.x,particlePos.y,particlePos.z);
	inputPoints[id.x].mortonId = mortonid;
	GroupMemoryBarrierWithGroupSync();
}



