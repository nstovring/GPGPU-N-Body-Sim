// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSCreateBVH
#pragma kernel CSSortMortonIDs
#pragma kernel CSGenerateBoundingSpheres
//#pragma kernel CSLoad
struct particle{
float3 position;
float3 direction;
float3 color;
float radius;
uint mortonId;
int collision;
};

struct internalNode{
	int objectId;
	int nodeId;
	int parentId;
	int2 intNodes;
	int2 leaves;
	float3 minPos;
	float3 maxPos;
	float sRadius;
	int visited;
	uint mortonId;
};
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
static const float PI = 3.14159265f;

globallycoherent RWStructuredBuffer<particle> inputPoints;
globallycoherent RWStructuredBuffer<internalNode> internalNodes;
globallycoherent RWStructuredBuffer<internalNode> leafNodes;

float DeltaTime;
float speed;
float angularSpeed;
float gravity;
float radius;
float3 gravityVec;
// Inverse of Part1By1 - "delete" all odd-indexed bits
uint Compact1By1(uint x)
{
  x &= 0x55555555;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
  x = (x ^ (x >>  1)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
  x = (x ^ (x >>  2)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
  x = (x ^ (x >>  4)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
  x = (x ^ (x >>  8)) & 0x0000ffff; // x = ---- ---- ---- ---- fedc ba98 7654 3210
  return x;
}

// Inverse of Part1By2 - "delete" all bits not at positions divisible by 3
uint Compact1By2(uint x)
{
  x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
  x = (x ^ (x >>  2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
  x = (x ^ (x >>  4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
  x = (x ^ (x >>  8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
  x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
  return x;
}

uint DecodeMorton3X(uint code)
{
  return Compact1By2(code >> 0);
}

uint DecodeMorton3Y(uint code)
{
  return Compact1By2(code >> 1);
}

uint DecodeMorton3Z(uint code)
{
  return Compact1By2(code >> 2);
}

float3 DecodeMortornToVector(uint code){

uint x = DecodeMorton3X(code);
uint y = DecodeMorton3Y(code);
uint z = DecodeMorton3Z(code);
return float3(x,y,z);
}

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uint expandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

// Calculates a 30-bit Morton code for the
// given 3D point located within the unit cube [0,1].
uint morton3D(float x, float y, float z)
{
    x = min(max(x * 1024.0f, 0.0f), 1023.0f);
    y = min(max(y * 1024.0f, 0.0f), 1023.0f);
    z = min(max(z * 1024.0f, 0.0f), 1023.0f);
    uint xx = expandBits((uint)x);
    uint yy = expandBits((uint)y);
    uint zz = expandBits((uint)z);
    return xx * 4 + yy * 2 + zz;
}



bool isLeaf(internalNode node){
	if(node.objectId != -1)
		return true;
	return false;
}

void GetChildren(internalNode node, out internalNode childA, out internalNode childB){
	int2 leaves = node.leaves;
	int2 intNodes = node.intNodes;
	childA.nodeId = -1;
	childB.nodeId = -1;

	if(leaves.x != -1)
		childA = leafNodes[leaves.x];
	if(leaves.y != -1)
		childB = leafNodes[leaves.y];
	if(intNodes.x != -1)
		childA = internalNodes[intNodes.x];
	if(intNodes.y != -1)
		childB = internalNodes[intNodes.y];
}

internalNode CalculateBoundingSphere(internalNode node){

	internalNode childA;
	internalNode childB;
	GetChildren(node,childA,childB);

	float3 parentPos = (childA.minPos + childB.minPos)/2; 
	float parentR = (distance(childA.minPos,childB.minPos) * angularSpeed) + (childA.sRadius + childB.sRadius)/2;

	node.minPos = parentPos;
	node.sRadius = parentR;
	return node;
}

void CalculateAABB(internalNode node,out float3 minPoint,out float3 maxPoint){

	internalNode childA;
	internalNode childB;
	GetChildren(node,childA,childB);
	float3 posAA = childA.minPos;
	float3 posAB = childA.maxPos;
	float3 posBA = childB.minPos;
	float3 posBB = childB.maxPos;
	float xmin = min(min(posBA.x,posBB.x),min(posAA.x,posAB.x));
	float ymin = min(min(posBA.y,posBB.y),min(posAA.y,posAB.y));
	float zmin = min(min(posBA.z,posBB.z),min(posAA.z,posAB.z));

	float xmax = max(max(posBA.x,posBB.x),max(posAA.x,posAB.x));
	float ymax = max(max(posBA.y,posBB.y),max(posAA.y,posAB.y));
	float zmax = max(max(posBA.z,posBB.z),max(posAA.z,posAB.z));

	minPoint = float3(xmin,ymin,zmin);
	maxPoint = float3(xmax,ymax,zmax);
}

bool AABBOverlap(float3 minA, float3 maxA, float3 minB, float3 maxB){
	 return (minA.x <= maxB.x && maxA.x >= minB.x) &&
         (minA.y <= maxB.y && maxA.y >= minB.y) &&
         (minA.z <= maxB.z && maxA.z >= minB.z);
}

internalNode GetRoot(){
	return internalNodes[0];
}
void TraverseBVHIterative(particle leaf, float radius, out int collisionList[32], int idx){
	internalNode node = GetRoot();
	int stack[32] =  {-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2};

	for(uint i = 0; i < 32; i++){
	stack[i] = -2;
	collisionList[i] = -1;
	}

	int traversalCount = 0;
	int collisionCount = 0;
	int maxLoop = 0;
	do{
		internalNode childA;
		internalNode childB;
		GetChildren(node,childA, childB);

		float3 AABBRadius = float3(radius,radius,radius) * angularSpeed;
		bool overlapA = AABBOverlap(leaf.position - AABBRadius, leaf.position + AABBRadius, childA.minPos, childA.maxPos) && childA.nodeId != -1;
		bool overlapB = AABBOverlap(leaf.position - AABBRadius, leaf.position + AABBRadius, childB.minPos, childB.maxPos) && childB.nodeId != -1;


		if(overlapA && isLeaf(childA) && childA.objectId != idx){
			collisionList[collisionCount] = childA.objectId;
			collisionCount++;
		}
		if(overlapB && isLeaf(childB) && childB.objectId != idx){
			collisionList[collisionCount] = childB.objectId;
			collisionCount++;
		}

		bool traverseA = (overlapA && !isLeaf(childA));
        bool traverseB = (overlapB && !isLeaf(childB));

        if (!traverseA && !traverseB){
			stack[traversalCount] = -1;
			traversalCount--;
			traversalCount = traversalCount <= 0 ? 0 : traversalCount;
			if (stack[traversalCount] == -1)
			{
				return;
			}
			node = internalNodes[stack[traversalCount]];
		}else{
			if(traverseA)
			node = childA;
			else
			node = childB;
		
			if (traverseA && traverseB){
			stack[traversalCount] = childB.nodeId;
			traversalCount++;
			}
		}
		maxLoop ++;
	}while(stack[traversalCount] != -1 && maxLoop < 64);//; && collisionCount < 32);//traversing && traversalCount < 64);

}
bool simpleCollision(float3 Q, float3 P, float r){
float dist = distance(Q,P);
if(dist < r){
return true;
}
return false;
}

float3 ApplyVelocity(float3 direction){
	float c = 0.1;
	float3 friction = normalize(direction) *-1 * c;
	direction += friction * DeltaTime;
	direction += gravityVec * gravity  * DeltaTime;
	return direction;
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 Gid  : SV_GroupID,
	uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
	AllMemoryBarrierWithGroupSync();

	//internalNode leaf = leafNodes[id.x];
	particle curParticle = inputPoints[id.x];

	
	GroupMemoryBarrierWithGroupSync();
	float3 velocity = ApplyVelocity(inputPoints[id.x].direction);
	float3 curPoint = inputPoints[id.x].position;

	particle l = curParticle;
	float velMagnitude = length(l.direction);
	float3 reflections = float3(0,0,0);
	int collisionList[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	for (int j = 0; j < 2; j++) {
		TraverseBVHIterative(curParticle, radius, collisionList, id.x);
		[unroll(32)]
		for (int i = 0; i < 32; i++) {
			if (collisionList[i] > -1) {
				particle p = inputPoints[collisionList[i]];

				float dist = distance(l.position, p.position);
				float3 N = normalize(l.position - p.position);
				if (dist < radius)//  t > 0 && t < 1)// d <= pow(radius*2,2))
				{
					float3 N = normalize(l.position - p.position);
					velocity += N;// normalize(reflect(l.direction, N)) * length(l.direction);// normalize(vel + N) * length(vel);
					velocity *= 0.5;
					GroupMemoryBarrierWithGroupSync();
				}
			}
		}
		curParticle.position += velocity * DeltaTime * speed * 0.5;
	}
	
	curPoint +=velocity * DeltaTime * speed;
	//
	if(curPoint.x > 1 - radius){
	curPoint.x =  1 - radius;
	velocity.x *=-1;
	}else if(curPoint.x < 0 + radius){
	curPoint.x = 0 + radius;
	velocity.x *=-1;
	}
	
	if(curPoint.y > 1 - radius){
	curPoint.y =  1 - radius;
	velocity.y *=-1;
	}else if(curPoint.y < 0 + radius){
	curPoint.y = 0 + radius;
	velocity.y *=-1;
	}
	
	if(curPoint.z >  1 - radius){
	curPoint.z =  1 - radius;
	velocity.z *=-1;
	}else if(curPoint.z < 0 + radius){
	curPoint.z = 0 + radius;
	velocity.z *=-1;
	}
	inputPoints[id.x].direction = velocity;
	inputPoints[id.x].position = curPoint;
	inputPoints[id.x].mortonId = morton3D(curPoint.x,curPoint.y,curPoint.z);
	inputPoints[id.x].radius = radius;
	GroupMemoryBarrierWithGroupSync();
}

//LVBH Construction From here on
//Count leading zeros method
int clz1( uint x )
{
  int n;
  if (x == 0) return 32;

  for (n = 0; ((x & 0x80000000) == 0); n++, x <<= 1);
  return n;
}
int clz3(uint x){
	if (x == 0){ 
	return 32;
	}

    uint n = 0;
    if ((x & 0xFFFF0000) == 0){ 
	n = n + 16;  
	x = x << 16;
	}
    if ((x & 0xFF000000) == 0){ 
	n = n +  8;
	x = x <<  8;
	}
    if ((x & 0xF0000000) == 0) {n = n +  4;  x = x <<  4;}
    if ((x & 0xC0000000) == 0) {n = n +  2;  x = x <<  2;}
    if ((x & 0x80000000) == 0) {n = n +  1;}
    return n;
}
//Deeper Hierarchy functions:
int findSplit(int first, int last)
{
    uint firstCode = leafNodes[first].mortonId;
    uint lastCode = leafNodes[last].mortonId;
    
    //When morton codes are identical we want to return the first id
    //because if we split it in the middle, both will try to orientate
    //towards the same direction
    
    //to split it in the middle would be the best but since it would be harder
    //for the range detector we do it this way (both ways less instructions needed:
    //here: (first + last) >> 1 to "first" and
    //in determine range we can reduce it to seek forward instead of tetermining the
    //sub direction and stuff...
    if (firstCode == lastCode)
        //return (first + last) >> 1;
      return first;
	
    // Calculate the number of highest bits that are the same
    // for all objects, using the count-leading-zeros intrinsic.
    int commonPrefix = clz3(firstCode ^ lastCode);

    // Use binary search to find where the next bit differs.
    // Specifically, we are looking for the highest object that
    // shares more than commonPrefix bits with the first one.

    int split = first; // initial guess
    int step = last - first;
    do
    {
        step = (step + 1) >> 1; // exponential decrease
        int newSplit = split + step; // proposed new position

        if (newSplit < last)
        {
            uint splitCode = leafNodes[newSplit].mortonId;
            int splitPrefix = clz3(firstCode ^ splitCode);
            if (splitPrefix > commonPrefix)
                split = newSplit; // accept proposal
        }
    }
    while (step > 1);

    return split;
}
int2 determineRange(int index)
{
  //so we don't have to call it every time
  uint lso, stride;
  inputPoints.GetDimensions(lso,stride);
  //uint lso = 1024;
  lso = lso-1;
  //tadaah, it's the root node
  if(index == 0)
    return int2( 0, lso);
  //direction to walk to, 1 to the right, -1 to the left
  int dir;
  //morton code diff on the outer known side of our range ... diff mc3 diff mc4 ->DIFF<- [mc5 diff mc6 diff ... ] diff .. 
  int d_min;
  int initialindex = index;
  
  uint minone = leafNodes[index-1].mortonId;
  uint precis = leafNodes[index].mortonId;
  uint pluone = leafNodes[index+1].mortonId;

  //AllMemoryBarrierWithGroupSync();
  GroupMemoryBarrierWithGroupSync();

  if((minone == precis && pluone == precis))
  {
    //set the mode to go towards the right, when the left and the right
    //object are being the same as this one, so groups of equal
    //code will be processed from the left to the right
    //and in node order from the top to the bottom, with each node X (ret.x = index)
    //containing Leaf object X and nodes from X+1 (the split func will make this split there)
    //till the end of the groups
    //(if any bit differs... DEP=32) it will stop the search
    while(index > 0 && index < lso )
    {
       //move one step into our direction
       index += 1;
       if(index >= lso){
       //we hit the left end of our list
	 	break;
	 	}
	  
      if(leafNodes[index].mortonId != leafNodes[index+1].mortonId){
       //there is a diffrence
	 	break;
	 	}
    }
    //return the end of equal grouped codes
    return int2(initialindex,index);
}else{
    //Our codes differ, so we seek for the ranges end in the binary search fashion:
    int2 lr= int2(clz3(precis ^ minone),clz3(precis ^ pluone));
    //now check wich one is higher (codes put side by side and wrote from up to down)
      if(lr.x > lr.y)
      {//to the left, set the search-depth to the right depth
	dir = -1;
	d_min = lr.y;
      }else{//to the right, set the search-depth to the left depth
	dir = 1;
	d_min = lr.x;
      }
    }
    //Now look for an range to search in (power of two)
    int l_max = 2;
    //so we don't have to calc it 3x
    int testindex = index + l_max*dir;
    while((testindex<=lso&&testindex>=0)?(clz3(precis ^ leafNodes[testindex].mortonId)>d_min):(false))
    {
		l_max *= 2;testindex = index + l_max*dir;
	}
	
    int l = 0;
    //go from l_max/2 ... l_max/4 ... l_max/8 .......... 1 all the way down
    for(uint div = 2 ; l_max / div >= 1 ; div *= 2){
      //calculate the ofset state
        int t = l_max/div;
	//calculate where to test next
        int newTest = index + (l + t)*dir;
	//test if in code range
        if (newTest <= lso && newTest >= 0)
        {
            int splitPrefix = clz3(precis ^ leafNodes[newTest].mortonId);
	    //and if the code is higher then our minimum, update the position
            if (splitPrefix > d_min)
	    l = l+t;
        }
    }
    //now give back the range (in the right order, [lower|higher])
    if(dir==1)
      return int2(index,index + l*dir);
    else
      return int2(index + l*dir,index);
	return int2(0,0);
}
//if Neccesarry recursively until two arrays remain
//Step two for each array pair execute parrallel merge
//This includes every thread performing a binary search on their paired arrays.
//Finding a value smaller than itself and summing the indices of the pair +1 to find the destination index
// if no value found then no change to index, if largest value and largest index no change to index.
//This results in a single array, which up the recursion tree is then paired with a merged array from a different leaf.
//Process continues until i have one continous sorted array. Algorithm should have log(k)*n*(log(n)) running time 
int BinarySearch(uint idx, uint mortonCode) {
	uint count, stride;
	inputPoints.GetDimensions(count,stride);
	//int count = 1024;
	int arraySize = 512;
	int normalizedIndex = idx % arraySize;
	int direction = 0;
	
	int groupAmount = count / arraySize;
	int returnValue = idx % arraySize;
	for (int i = 1; i < groupAmount; i++) {
		int center = ((idx + arraySize * i) % count) - normalizedIndex + arraySize / 2;
		uint step = center - 1;
		float stepScale = 0.25;

		do
		{
			step += direction;

			uint middle = inputPoints[step].mortonId;
			uint pluOne = inputPoints[step + 1].mortonId;
			int normalizedStep = step % arraySize;

			if ((arraySize)*stepScale < 1 && middle < mortonCode && pluOne < mortonCode) {
				return step + 1;
			}

			if (mortonCode < middle) {
				direction = -1 * (arraySize)*stepScale;
				stepScale *= 0.5;
			}
			else if (pluOne < mortonCode) {
				direction = 1 * (arraySize)*stepScale;
				stepScale *= 0.5;

			}
			else if (middle < mortonCode && pluOne > mortonCode)
			{
				return ((normalizedStep)+normalizedIndex + 1) % count;
			}
		} while ((arraySize)*stepScale > 0);

	}
	return idx % arraySize;
}

[numthreads(32,1,1)]
void CSCreateBVH (uint3 id : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
    int index = BinarySearch(id.x, inputPoints[id.x].mortonId); 
	//indexes[GI] = index;
	//GroupMemoryBarrierWithGroupSync();
	leafNodes[index].objectId = id.x;
	leafNodes[index].nodeId = index;
	leafNodes[index].mortonId = inputPoints[id.x].mortonId;
	leafNodes[index].minPos = inputPoints[id.x].position;// -float3(radius, radius, radius) / 2;
	leafNodes[index].maxPos = inputPoints[id.x].position;// +float3(radius, radius, radius) / 2;
	leafNodes[index].sRadius = radius;
	internalNodes[id.x].objectId = -1;
	internalNodes[id.x].visited = 0;
	internalNodes[id.x].nodeId = id.x;
	//AllMemoryBarrierWithGroupSync();

	int2 inrange = determineRange(id.x);
	int first = inrange.x;
	int last = inrange.y;
	
	int split = findSplit(first,last);
	
	int2 leaves;
	int2 intNodes;
	
	GroupMemoryBarrierWithGroupSync();
	if(split == first){
		leaves.x = split;
		leafNodes[split].parentId = id.x;
		intNodes.x = -1;
		//leafNodes[split].objectId = inputPoints[split].
	}
	else{
		intNodes.x = split;
		internalNodes[split].parentId = id.x;
		leaves.x = -1;
	}
	GroupMemoryBarrierWithGroupSync();
	
	//internalNode childB;
	if(split +1 == last){
		leaves.y =  split +1;
		leafNodes[split + 1].parentId = id.x;
		intNodes.y = -1;
	}
	else{
		intNodes.y = split +1;
		internalNodes[split + 1].parentId = id.x;
		leaves.y = -1;
	}
	GroupMemoryBarrierWithGroupSync();
	internalNodes[id.x].leaves = leaves;
	internalNodes[id.x].intNodes = intNodes;
}	
	
[numthreads(32,1,1)]
void CSGenerateBoundingSpheres(uint3 id: SV_DISPATCHTHREADID){
	int parentId = leafNodes[id.x].parentId;
	int traversalCount = 0;
	int count = 0;
	internalNode parent;
	do{
		parent = internalNodes[parentId];
		float3 Min;
		float3 Max;
		CalculateAABB(parent, Min, Max);
		//parent = CalculateBoundingSphere(parent);
		internalNodes[parentId].minPos = Min;
		internalNodes[parentId].maxPos = Max;
		//internalNodes[parentId].sRadius = parent.sRadius;
		parentId = parent.parentId;
		count++;
	}while(parent.nodeId != 0 && count < log2(1024));
}

[numthreads(32,1,1)]
void CSSortMortonIDs (uint3 id : SV_DispatchThreadID)
{
	float3 particlePos =  inputPoints[id.x].position; 
	uint mortonid = morton3D(particlePos.x,particlePos.y,particlePos.z);
	inputPoints[id.x].mortonId = mortonid;
	GroupMemoryBarrierWithGroupSync();
}
