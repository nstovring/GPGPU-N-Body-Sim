// shadertype=unity
// Each #kernel tells which function to compile; you can have many kernels


//#pragma kernel CSLoad

#include "BVHTraversal.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


float DeltaTime;
float speed;
float angularSpeed;
float gravity;
float radius;
float3 gravityVec;


float3 ApplyVelocity(float3 direction){
	float c = 0.1;
	float3 friction = normalize(direction) *-1 * c;
	direction += friction * DeltaTime;
	direction += gravityVec * gravity  * DeltaTime;
	return direction;
}
float3 Normalize(float3 v) {
	float len = length(v);
	float3 normal = (len == 0.0) ? float3(0.0, 0.0, 0.0) : v / len;
	return normal;
}

float3 calculateCollisionForce(float3 i, float3 j, float k, float diameter, float3 vi, float3 vj, float damping) {
	float3 repulsiveForce = float3(0, 0, 0);
    float3 tangentialForce = float3(0, 0, 0);
    float3 dampingForce = float3(0, 0, 0);
	float3 rPosition = j - i;
	float3 rVelocity = vj - vi;

    repulsiveForce = -k * (diameter - distance(i,j)) * (Normalize(rPosition));

	dampingForce = (rVelocity) * damping;
	tangentialForce = rVelocity - dot(rVelocity, Normalize(rPosition)) * Normalize(rPosition);
    return repulsiveForce +dampingForce + tangentialForce;
}

#pragma kernel TraversalKernel
[numthreads(MainKernelThreadX, 1, 1)]
void TraversalKernel(uint3 id : SV_DispatchThreadID, uint3 Gid : SV_GroupID,
	uint3 GTid : SV_GroupThreadID,
	uint GI : SV_GroupIndex)
{
    internalNode leaf = boundingLeafNodes[id.x]; //inputPoints[leafNodes[id.x].objectId];
    particle curParticle = mergeOutputBuffer[leaf.objectId]; //;mergeOutputBuffer[leaf.objectId];
    float3 velocity = curParticle.direction;
    float3 curPoint = curParticle.position;
    float3 collisionForce = float3(0, 0, 0);
    float steeringForce = float3(0, 0, 0);
    int collisionList[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
    TraverseBVHIterative(leaf, radius, collisionList);
	[unroll(32)]
    for (int i = 0; i < 32; i++)
    {
        if (collisionList[i] > -1)
        {
            particle p = mergeOutputBuffer[collisionList[i]];
    
            float dist = distance(curPoint, p.position);
            if (dist < radius)//  t > 0 && t < 1)// d <= pow(radius*2,2))
            {
                float3 c = calculateCollisionForce(curPoint, p.position, 100, radius * 2, velocity, p.direction, 0.1);
                collisionForce += c;
            }
            steeringForce += p.direction * (radius * 4 - distance(curPoint, p.position));

        }
    }
    if (curPoint.y < 0 + radius)
    {
        collisionForce += calculateCollisionForce(curPoint, float3(curPoint.x, 0 + radius, curPoint.z), 100, radius * 2, velocity, float3(0, 1, 0), 0.1);
    }

    float3 force = collisionForce + gravityVec * gravity * 0.25 + steeringForce;
    float3 acceleration = force / 0.25;
	//acceleration *= DeltaTime;
    velocity = velocity + acceleration * DeltaTime; // +collisionForce;

    velocityBuffer[leaf.objectId] = velocity;

}


#pragma kernel CSMain
[numthreads(MainKernelThreadX, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 Gid  : SV_GroupID,
	uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
    internalNode leaf = boundingLeafNodes[id.x]; //inputPoints[leafNodes[id.x].objectId];
    particle curParticle = mergeOutputBuffer[leaf.objectId]; //;mergeOutputBuffer[leaf.objectId];
    float3 velocity = velocityBuffer[leaf.objectId];
	float3 curPoint = curParticle.position;
	//float3 collisionForce = float3(0, 0, 0);
    //
    //
	//int collisionList[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
    //TraverseBVHIterative(leaf, radius, collisionList);
	//[unroll(32)]
	//for (int i = 0; i < 32; i++) {
	//	if (collisionList[i] > -1) {
	//		particle p = mergeOutputBuffer[collisionList[i]];
    //
    //        float dist = distance(curPoint, p.position);
	//		if (dist < radius)//  t > 0 && t < 1)// d <= pow(radius*2,2))
	//		{
    //            float3 c = calculateCollisionForce(curPoint, p.position, 1500, radius*2, velocity, p.direction, 20);
	//			collisionForce += c;
	//		}
	//	}
	//}
    //if (curPoint.y < 0 + radius)
    //{
    //    collisionForce += calculateCollisionForce(curPoint, float3(curPoint.x, 0 + radius, curPoint.y), 10, radius * 2, velocity, float3(0, 1, 0), 20);
    //}
    //
    //
	//float3 force = collisionForce + gravityVec * 1 * gravity;
	//float3 acceleration = force / 1;
	////acceleration *= DeltaTime;
	//velocity = velocity + acceleration * DeltaTime;// +collisionForce;
    if (curPoint.x > 0.5 - radius)
    {
        curPoint.x = 0.5 - radius;
        velocity.x *= -1;
    }
    else if (curPoint.x < 0 + radius)
    {
        curPoint.x = 0 + radius;
        velocity.x *= -1;
    }
	
    if (curPoint.y > 1 - radius)
    {
        curPoint.y = 1 - radius;
        velocity.y *= -1;
    }
	//else if(curPoint.y < 0 + radius){
	//curPoint.y = 0 + radius;
	//velocity.y *=-1;
	//}
	
    if (curPoint.z > 0.5 - radius)
    {
        curPoint.z = 0.5 - radius;
        velocity.z *= -1;
    }
    else if (curPoint.z < 0 + radius)
    {
        curPoint.z = 0 + radius;
        velocity.z *= -1;
    }

	curPoint = curPoint + velocity * DeltaTime * speed;

	
    curParticle.direction = velocity;
    curParticle.position = curPoint;
    curParticle.mortonId = morton3D(curPoint.x, curPoint.y, curPoint.z);
    curParticle.radius = radius;
    inputPoints[id.x] = curParticle;
	//DeviceMemoryBarrier();
}


#pragma kernel WriteNodeData
[numthreads(ThreadX, 1, 1)]
void WriteNodeData(uint3 id : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID,
	uint  GI : SV_GroupIndex)
{
    inputPoints[id.x] = mergeOutputBuffer[id.x];
    internalNode leaf = leafNodes[id.x];
	leaf.parentId = -1;
	leaf.objectId = id.x;
	leaf.nodeId = id.x;
	leaf.mortonId = mergeOutputBuffer[id.x].mortonId;
	leaf.minPos = mergeOutputBuffer[id.x].position - float3(radius, radius, radius) / 2;
	leaf.maxPos = mergeOutputBuffer[id.x].position + float3(radius, radius, radius) / 2;
    leaf.sRadius = radius;
	
    leafNodes[id.x] = leaf;
    boundingLeafNodes[id.x] = leaf;

}





#pragma kernel CSSortMortonIDs
[numthreads(ThreadX,1,1)]
void CSSortMortonIDs (uint3 id : SV_DispatchThreadID)
{
	float3 particlePos =  inputPoints[id.x].position; 
	uint mortonid = morton3D(particlePos.x,particlePos.y,particlePos.z);
	inputPoints[id.x].mortonId = mortonid;
	GroupMemoryBarrierWithGroupSync();
}



